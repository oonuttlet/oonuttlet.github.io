{
  "hash": "690cd35dc8f35391b1cc6261901c0493",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Flow Mapping\"\nauthor: \"Harrison DeFord\"\ndate: '2022-05-05'\noutput: html_document\nexecute: \n  eval: false\n---\n\n\n\n\n\n## Setup\n\nThis script uses outputs from the previous 3 Rmd files to create a flow map based on the `mapdeck` package, and bins start and end points by hexes. This workflow is not currently automated for other datasets, but this is a minimal working example to show that it can be expanded to other metro areas.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflow_lines <- readRDS(\"G:/My Drive/GES486/final_proj/results/flow_lines.RDS\") %>%\n  st_transform(crs = 3857)\nbaltimore_bound = counties(state = \"MD\", cb = TRUE) %>%\n  filter(str_detect(GEOID, \"24510|24005\")) %>%\n  st_transform(crs = 3857)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbalt_hex <- st_make_grid(baltimore_bound, #create 2000m hex grid\n                         cellsize = c(1600,1600),\n                         what = \"polygons\",\n                         square = FALSE,\n                         crs = 3857\n                         ) %>%\n  st_as_sf() %>%\n  mutate(hex_id = paste(\"hex_\", row_number(), sep = \"\"))\nbalt_hex.intersects <- st_intersects(st_union(baltimore_bound), balt_hex)\nbalt_hex.subset <- balt_hex[balt_hex.intersects[[1]],]\nbalt_centroid <- st_centroid(balt_hex.subset) %>% st_transform(4326) #dataframe of centroids of each hex\nbaltimore_bound <- baltimore_bound %>% st_transform(4326)\ntm_shape(baltimore_bound)+\n  tm_polygons(col = \"#bdbdbd\", border.col = \"black\", lwd = 2)+\n  tm_shape(balt_hex)+\n  tm_borders()\n```\n:::\n\n\n\nThis next block of code is a mess, but I couldn't get `dplyr` and `sf` to cooperate with some of these dataframes, which contained multiple geometry columns. This can be cleaned up (and probably will be), but for now, this works for the data that I have.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbalt_hex <- balt_hex %>% st_transform(4326)\nbalt_hex.subset <- balt_hex.subset %>% st_transform(4326)\nflow_lines_sf <- st_as_sf(flow_lines)\nflow_lines_sf <- st_transform(flow_lines_sf, crs = 4326)\nflow_lines_sf <- st_set_geometry(flow_lines_sf, flow_lines_sf$start_geom) %>% st_transform(4326)\nstart_points_join <- st_join(flow_lines_sf, balt_hex.subset) #spatial join of start points (set start points as active geometry in previous step)\nflow_lines_sf <- st_set_geometry(flow_lines_sf, flow_lines_sf$end_geom) %>% st_transform(4326)\nend_points_join <- st_join(flow_lines_sf, balt_hex.subset) #in similar fashion, spatial join of end points\nflow_lines_sf$start_hex_id <- start_points_join$hex_id\nflow_lines_sf$end_hex_id <- end_points_join$hex_id\nflow_lines_sf <- left_join(st_drop_geometry(flow_lines_sf), balt_centroid, by = c(\"start_hex_id\" = \"hex_id\")) #join centroid of endpoint hex to row\nflow_lines_sf <- rename(flow_lines_sf, start_centroid = x)\nflow_lines_sf <- left_join(flow_lines_sf, balt_centroid, by = c(\"end_hex_id\" = \"hex_id\")) #likewise for end\nflow_lines_sf <- rename(flow_lines_sf, end_centroid = x)\nflow_lines_sf <- st_sf(flow_lines_sf) %>% st_transform(4326)\nflow_lines_arc <- rename(count(flow_lines_sf, start_hex_id, end_hex_id), wgt = n)\nflow_lines_arc <- flow_lines_arc %>% mutate(scale_weight = (3*wgt))\nflow_lines_arc <- left_join(st_drop_geometry(flow_lines_arc), balt_centroid, by = c(\"end_hex_id\" = \"hex_id\"))\nflow_lines_arc <- left_join(flow_lines_arc, balt_centroid, by = c(\"start_hex_id\" = \"hex_id\"))\nflow_lines_arc <- flow_lines_arc %>% rename(end_centroid = x.x, start_centroid = x.y) %>% st_sf()\nflow_lines_arc <- flow_lines_arc %>% st_transform(4326)\n```\n:::\n\n\n\nThe following methodology, to count start and end points within hexes, is adapted from [Matt Herman's blog post](https://mattherman.info/blog/point-in-poly/) detailing the counting of trees within NYC census geographies.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart_hex_count <- count(as_tibble(start_points_join), hex_id) %>% rename(start_in_hex = n)\nend_hex_count <- count(as_tibble(end_points_join), hex_id) %>% rename(end_in_hex = n)\nbalt_hex.subset <- left_join(balt_hex.subset, start_hex_count, by = c(\"hex_id\" = \"hex_id\"))\nbalt_hex.subset <- left_join(balt_hex.subset, end_hex_count, by = c(\"hex_id\" = \"hex_id\"))\nbalt_hex.subset <- balt_hex.subset %>% replace(is.na(.), 0)\nbalt_hex.subset <- balt_hex.subset %>% mutate(total_endpoint = start_in_hex + end_in_hex) \nbalt_hex.subset <- balt_hex.subset %>% st_transform(4326)\n```\n:::\n\n\n\nThree flow maps can be generated from this data: one symbolized with start points per hex, one with end points per hex, and one with total endpoints per hex.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflow_lines_arc %>%\n  mapdeck(token = Sys.getenv(\"MAPBOX_TOKEN\")) %>%\n  add_arc(origin = \"start_centroid\",\n          destination = \"end_centroid\",\n          stroke_from = \"#000000\",\n          stroke_to = \"#000000\",\n          stroke_width = \"scale_weight\",\n          update_view = TRUE) %>%\n  add_sf(data = balt_hex.subset,\n         fill_colour = \"start_in_hex\",\n         fill_opacity = 180,\n         legend = TRUE\n         )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflow_lines_arc %>%\n  mapdeck(token = Sys.getenv(\"MAPBOX_TOKEN\")) %>%\n  add_arc(origin = \"start_centroid\",\n          destination = \"end_centroid\",\n          stroke_from = \"#000000\",\n          stroke_to = \"#000000\",\n          stroke_width = \"scale_weight\",\n          update_view = TRUE) %>%\n  add_sf(data = balt_hex.subset,\n         fill_colour = \"end_in_hex\",\n         fill_opacity = 180,\n         legend = TRUE\n         )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflow_lines_arc %>%\n  mapdeck(token = Sys.getenv(\"MAPBOX_TOKEN\")) %>%\n  add_arc(origin = \"start_centroid\",\n          destination = \"end_centroid\",\n          stroke_from = \"#000000\",\n          stroke_to = \"#000000\",\n          stroke_width = \"scale_weight\",\n          update_view = TRUE) %>%\n  add_sf(data = balt_hex.subset,\n         fill_colour = \"total_endpoint\",\n         fill_opacity = 180,\n         legend = TRUE\n         )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nif(!file.exists(\"../results/flow_lines_arc.RDS\")){\n  saveRDS(flow_lines_arc, file = \"../results/flow_lines_arc.RDS\")\n}\nif(!file.exists(\"../results/balt_hex.RDS\")){\n  saveRDS(balt_hex, file = \"../results/balt_hex.RDS\")\n}\n```\n:::\n",
    "supporting": [
      "hexagons_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}