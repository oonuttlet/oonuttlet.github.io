{
  "hash": "e80749e46724575c98d77ca71c34d48f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Generating Flow Lines\"\nauthor: \"Harrison DeFord\"\ndate: '2022-05-05'\noutput: html_document\n---\n\n\n\n## Setup\n\nThis script is meant to be run after QGIS 2.x.x is used to generate paths from the timeseries data generated in the previous script. The older version of QGIS is necessary to use the Points to Paths plugin, which allows for separate lines per vertex (important because we define each 15-minute interval as a distinct trip, even if movement was detected over several consecutive intervals). Within the plugin, bike IDs and row numbers were concatenated using field calculator in order to create a movement ID, which was used to define a trip as a movement of over 50 meters within 15 minutes to account for GPS variability on scooters.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflow_lines <- st_read(\"../results/trip_id_p2p.shp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `trip_id_p2p' from data source \n  `D:\\website\\oonuttlet.github.io\\posts\\finalproj\\results\\trip_id_p2p.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 255 features and 7 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: -8538362 ymin: 4755023 xmax: -8520945 ymax: 4774157\nProjected CRS: WGS 84 / Pseudo-Mercator\n```\n\n\n:::\n\n```{.r .cell-code}\ntrip_id_long <- st_read(\"../results/trip_id_long.gpkg\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `trip_id_long' from data source \n  `D:\\website\\oonuttlet.github.io\\posts\\finalproj\\results\\trip_id_long.gpkg' \n  using driver `GPKG'\nSimple feature collection with 10251 features and 13 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -8539536 ymin: 4754428 xmax: -8516307 ymax: 4775070\nProjected CRS: WGS 84 / Pseudo-Mercator\n```\n\n\n:::\n\n```{.r .cell-code}\nflow_lines_proj <- flow_lines %>% st_transform(4326)\n```\n:::\n\n\n\nWe use `lwgeom` to define the start and endpoints of each of our flow lines, so we have a directionality for our trips\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflow_lines$start_geom <- st_startpoint(flow_lines)\nflow_lines$end_geom <- st_endpoint(flow_lines)\nflow_lines_proj$start_geom <- st_startpoint(flow_lines_proj)\nflow_lines_proj$end_geom <- st_endpoint(flow_lines_proj)\n```\n:::\n\n\n\nSince almost all spatial file formats require only one geometry column, we write to an RDS file to preserve our geometries (for starts and ends, and in the next script for hexagon data as well).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflow_lines <- flow_lines %>% mutate(dist = st_length(geometry))\nsummarise(flow_lines, mean = mean(dist))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1 feature and 1 field\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: -8538362 ymin: 4755023 xmax: -8520945 ymax: 4774157\nProjected CRS: WGS 84 / Pseudo-Mercator\n          mean                       geometry\n1 1289.586 [m] MULTILINESTRING ((-8523392 ...\n```\n\n\n:::\n\n```{.r .cell-code}\nif(!file.exists(\"../results/flow_lines.RDS\")){\n  saveRDS(object = flow_lines, file = \"../results/flow_lines.RDS\")\n}\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}